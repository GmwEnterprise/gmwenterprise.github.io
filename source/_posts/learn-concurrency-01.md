---
title: 学习Java并发（01）基本概念
date: 2019-12-31 11:33:06
categories: 并发
tags:
  - java
  - concurrency
---
## 前言

在工作中时常接触到并发环境，只是现有的框架已经在底层封装好了，可以直接调用。但总会有一些奇特的场景需要自己手动实现并发，所以了解原理是很重要的。本文用于记录学习并发过程中重要的点或思考。

本文只讨论基本概念，旨在用较为详细易懂的文字记录自己对于并发的一些理解。

## 什么是并发

并发（Concurrency）是指系统在同一时间段可同时处理多个任务，而同一时刻只有一个任务处于运行状态。

实际上对于单核CPU而言无法实现真正的同时运行多个任务。但是由于CPU运算速度极快，在一个短的时间单位内（比如0.001秒）执行一个任务，执行完马上切换到下一个任务。这样宏观看起来就像是在同时运行多个任务了。

与*并行（Parallel）*的区别：并行是指同一时刻可以同时运行多个任务。现代多核处理器都支持并行运算。并发强调系统支持多个任务同一时刻存在；并行强调系统支持多个任务同时运行。

## CPU核心数

可以理解为多处理器，双核CPU从程序的角度来看就等于可共享资源的两个单核处理器。对于单核处理器而言，任一时刻只能处理一个任务；然而多核处理器可以在同一时刻同时处理多个任务。由于现在的CPU基本都支持所谓的*超线程*，使得一个物理核心可以逻辑上实现两个任务的同时运行（比如Intel的i5处理器通常都是4核8线程，6核12线程），所以程序角度来看一个核心，系统在同一时刻可以同时运行的任务数为：CPU超线程数 * CPU个数。

## 进程与线程

### 基本概念

> 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，同时也是线程的容器。
> 
> 线程（Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

一个操作系统拥有多个进程，一个进程拥有至少一个线程。一个程序拥有一个或多个进程，通常应用为一个进程，但诸如Chrome、Firefox等应用也会拥有多个进程。一般而言进程之间无法共享资源，因为进程拥有独立的内存空间、资源分配等，多个进程之间互不影响；但线程却天然共享内存空间，所以多线程应用最大的问题就在于如何规避资源被多个线程同时访问，而多进程应用最大的问题就在于进程间通信。

### 线程的调度

CPU调度的基本单位是线程。对于进程的调度来说不同的系统之间存在不同的方式，这里不做探讨。

对于单核CPU而言，系统会针对每一个可执行线程分配所谓的**时间片**（指当前线程可执行时间），当该线程执行超过执行时间或离开可运行态时，CPU将会切换到下一个线程，如果之前线程未执行完，则暂停执行，等待下一次时间片分片；线程之间有优先级的划分，高优先级线程将有更多的几率获取到时间片。对于多数服务器而言，其使用的至强系列服务级芯片通常拥有6核以上，再加上超线程技术的加持，其可同时处理至少12个线程，线程获取到时间片的频次也大大增加。CPU拥有很高的主频，也就是其执行指令计算的时钟频率，主频越高，频率越快，一个时间单位能够执行的指令条数也就更多，一个线程所耗费的时间片也就会变少，所有线程的调度也会更加频繁。

对于一台服务器而言，程序的线程数并不是越大越好。线程数过大（上千上万）显然是不合适的，创建线程会消耗很多的系统资源，CPU切换上下文所耗费的成本也会更多，大量的线程也会长时间处于等待状态而无法及时处理。合适的数量大致如下：

> 线程数 = CPU核心数 / (1 - 阻塞系数)
> 阻塞系数 = 阻塞时间 / (阻塞时间 + 计算时间)

假设每个线程其阻塞时间为8个时间单位，计算时间为2个时间单位（对于大多数I/O系统而言，其阻塞时间通常大于计算时间，也就是说线程访问I/O多数时间处于等待状态），那么其阻塞系数就为0.8；那对于一个双核处理器而言，最好为其开启十个线程，才能不浪费系统资源，同时也能够兼顾到所有的线程。（由于不了解操作系统，我也一直在思考阻塞时难道文件系统不使用CPU吗？暂时先这么理解吧）

> *扩展：**协程**（Coroutine）又名纤程，可以理解为线程中的线程。一个进程可有多个线程，同时一个线程也可拥有多个协程。在一些高并发的原生语言中(比如[golang](https://golang.org/))自然支持，同时Java中也有第三方的库([quasar](https://docs.paralleluniverse.co/quasar/))支持。线程的切换需要依靠CPU执行上下文切换会产生开销，且支持的最大线程数有限，但协程是在程序内部实现的切换，不存在切换开销，而且协程存在于一个线程当中，不需要锁，无需担心写变量冲突的问题，所以其执行效率远高于线程。单台服务器可能最多支持几百个线程，但支持上百万的协程，如此可以极大地提升系统地并发能力。*

### 线程的状态

线程拥有五种基本状态：
- 创建：一个线程刚刚被创建出来；
- 就绪：线程目前处于可运行状态，等待获取时间片；
- 运行：线程获取到时间片，正在运行；
- 阻塞：线程因为一些原因放弃当前CPU，且该阶段无法获取CPU时间片；
- 死亡：线程执行完毕或产生异常被中止。

说法比较简略，但大致差不多。网络上对于这些状态的讨论众说纷纭，这里只简单描述一下抽象的概念。

### 阻塞

线程的几种状态中，阻塞状态是程序通常需要面临的一个问题。由于阻塞会导致当前线程暂停执行，放弃CPU时间片，如果所有的线程都要面临长时间的阻塞，则系统的性能也会面临瓶颈。

当线程访问一些资源时（I/O资源），由于当前资源不可获取，则当前线程放弃CPU的使用权，等待资源可获取。等待资源的这个状态则被称之为阻塞。当线程为阻塞状态时，什么事也不做。资源一旦可用，则会触发一个事件，使当前线程进入可运行态，重新等待CPU的时间片分配。这只是宏观上的理解，对于底层而言，系统要做的事情非常复杂。同样当线程面临同步访问变量时，等待锁分配的过程也被称为阻塞状态。简单而言，线程等待共享资源的使用权这个阶段就被称为阻塞状态。

